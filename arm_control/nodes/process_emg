#!/usr/bin/env python3
import rospy
from std_msgs.msg import Float32MultiArray, Int16, Bool
import enum
import numpy as np
from arm_control.utils import butter_highpass_filter, getTSD
from arm_control.classifier import predict
from std_srvs.srv import Empty


class Pose(enum.Enum):
    REST = 0
    FIST = 1
    WAVE_IN = 2
    WAVE_OUT = 3
    FINGERS_SPREAD = 4
    THUMB_TO_PINKY = 5
    UNKNOWN = 255

class Handler:
    def __init__(self):
        self.last_time = None
        self.current_time = None
        self.emg_examples = None
        self.formated_example = None
        self.featured_example = None
        self.predicted = 0
        self.raw_emg = None
        self.upper_emg_at_rest = None
        self.start_record = False
        self.rest_thresh = None

        self.longterm_myo_names = ['REST', 'WF', 'WE', 'RD', 'UD', 'FP', 'FS', 'HC', 'FP & WF', 'FP & WE',
                                    'FP & RD', 'FP & UD', 'FS & WF', 'FS & WE', 'FS & RD', 'FS & UD', 'HC & WF',
                                    'HC & WE', 'HC & RD', 'HC & UD', 'HC & FP', 'HC & FS']
        # self.longterm_myo_names = ['REST', 'FP & WF', 'FP & WE', 'FP & RD', 'FP & UD']
        self.emg_sub = rospy.Subscriber('myo_lower/myo_emg', Float32MultiArray, self.emg_callback)
        self.gest_sub = rospy.Subscriber('myo_lower/myo_gest', Int16, self.gest_callback)
        self.processed_emg_pub = rospy.Publisher('myo_lower/processed_emg', Float32MultiArray, queue_size = 10)
        self.pred_pub = rospy.Publisher('myo_lower/myo_pred', Int16, queue_size=1)
        self.bicep_pub = rospy.Publisher('myo_upper/rest_bicep', Bool, queue_size=1)
        rospy.Timer(rospy.Duration(1/10), self.pub_arm_stats) 

        self.record_upper_service = rospy.Service("record_upper", Empty, self.record_upper_callback)
        
        
    def emg_callback(self, data):
        self.raw_emg = data.data

        if self.last_time is None:
            self.last_time = rospy.get_time()
            self.current_time = self.last_time
        else:
            self.last_time = self.current_time
            self.current_time = rospy.get_time()

            msg = Float32MultiArray()
            msg.data  = self.proc_emg(self.raw_emg)
            self.processed_emg_pub.publish(msg)

            if self.start_record and self.predicted == 0:
                print("Recording. Keep arm at rest ")
                if self.upper_emg_at_rest is None:
                    self.upper_emg_at_rest = self.raw_emg
                else:
                    self.upper_emg_at_rest = np.row_stack((self.upper_emg_at_rest, self.raw_emg))

                    if len(self.upper_emg_at_rest) >= 500: # 2.5s window at 200Hz
                        self.start_record = False
                        m = np.mean(self.upper_emg_at_rest)
                        std = np.std(self.upper_emg_at_rest)
                        self.rest_thresh = np.abs(m + std)
                        print("Record Complete. ", np.shape(self.upper_emg_at_rest), " mean = ", m, " std = ", std)
                        print("Thresh = ", self.rest_thresh)


    
    def proc_emg(self, raw_emg):
        normalized_emg = []
        for emg in raw_emg:
            if emg < 0:
                e = emg/128
            else:
                e = emg/127
            normalized_emg.append(e)
        self.format_examples(normalized_emg)
        return normalized_emg
    

    def format_examples(self, new_example, window_size=50, size_non_overlap=10):
        if self.emg_examples is None:
            self.emg_examples = new_example
        else:
            self.emg_examples = np.row_stack((self.emg_examples, new_example))
        
        # store one window_size of signal
        if len(self.emg_examples) >= window_size:
            if not np.sum(self.emg_examples) == 0:   # avoid all zero signals
                # featured_example = getTSD(example.transpose())
                # self.emg_examples.append(np.array(featured_example).transpose().flatten())
                self.formated_example = butter_highpass_filter(self.emg_examples)
                self.featured_example = getTSD(self.formated_example.transpose())
                self.predicted = predict(self.featured_example)
            else:
                self.formated_example = np.zeros((252))
            # Remove part of the data of the example according to the size_non_overlap variable
            self.emg_examples = self.emg_examples[size_non_overlap:]
        
        # print(self.predicted, " --- exmaple = ", np.shape(self.emg_examples), " --- ", np.shape(self.formated_example), " --- ", np.shape(self.featured_example))
        self.formated_example = None
        self.featured_example = None

    def gest_callback(self, data):
        # print("myo_lower gest = ", Pose(data.data))
        self.gest = Pose(data.data)
        if self.gest == Pose.REST or self.gest == Pose.UNKNOWN:
            self.pub_group_cmd = True
        else: 
            self.pub_group_cmd = False
    
    def pub_arm_stats(self, event):
        msg = Int16()
        if (self.predicted == 3 or self.predicted == 4):
            if self.gest == Pose.WAVE_IN:
                msg.data =  1  
            elif self.gest == Pose.WAVE_OUT: 
                msg.data = 2
            else:
                msg.data = self.predicted
        # if self.start_record:
        print("predicted: ", self.predicted, " ", self.longterm_myo_names[self.predicted], " --- pub msg: ", \
                msg.data, " ", self.longterm_myo_names[msg.data])
        self.pred_pub.publish(msg)

        msg = Bool()
        if self.rest_thresh is None: # assume bicep is always at rest when no thresh is recorded 
            msg.data = True
        else:
            m = np.mean(self.raw_emg)
            std = np.std(self.raw_emg)
            # print("bicep ", m+std, " vs ", self.rest_thresh, " = ", np.abs(m+std) > self.rest_thresh)
            msg.data = False if np.abs(m+std) > self.rest_thresh else True
        self.bicep_pub.publish(msg)

    def record_upper_callback(self, res):
        print("recording upper EMG, keep arm at rest")
        self.start_record = True
        return []
    





def main():
    """ The main() function. """
    rospy.init_node('process_emg')
    handler = Handler()

    rospy.spin()

if __name__ == '__main__':
    try:
        main()
    except rospy.ROSInterruptException:
        pass
