#!/usr/bin/env python3
from connect_myo.myodriver import MyoDriver
from connect_myo.config import Config
import serial
import struct
from math import sqrt, degrees
from tf.transformations import quaternion_from_euler, quaternion_multiply, euler_from_quaternion
import rospy
from geometry_msgs.msg import Quaternion, Vector3, PoseStamped, Point, Pose
from sensor_msgs.msg import Imu
from std_msgs.msg import Header, Float32MultiArray, Int16

class Handler:
    def __init__(self):
        # Run
        self.config = Config()
        self.num_myo = rospy.get_param('num_myo')
        # self.myo_lower_address = rospy.get_param('myo_lower_address')
        # self.myo_upper_address = rospy.get_param('myo_upper_address')
        # self.myo_lower_address = struct.pack('6B', *self.myo_lower_address)
        # self.myo_upper_address = struct.pack('6B', *self.myo_upper_address)
        self.config.MYO_AMOUNT = self.num_myo
        self.myo_driver = None
        self.emg_val = None
        self.imu_val = None
        self.gest_val = None

        # ROS Params
        self.myo_name = rospy.get_param('myo_name')
        self.imuPub = [rospy.Publisher(f'{self.myo_name[0]}/myo_imu', Imu, queue_size=1),
                        rospy.Publisher(f'{self.myo_name[1]}/myo_imu', Imu, queue_size=1)]
        self.oriPub = [rospy.Publisher(f'{self.myo_name[0]}/myo_ori', Vector3, queue_size=1),
                       rospy.Publisher(f'{self.myo_name[1]}/myo_ori', Vector3, queue_size=1)]
        self.oriDegPub = [rospy.Publisher(f'{self.myo_name[0]}/myo_ori_deg', Vector3, queue_size=1),
                          rospy.Publisher(f'{self.myo_name[1]}/myo_ori_deg', Vector3, queue_size=1)]
        self.posePub = [rospy.Publisher(f'{self.myo_name[0]}/pose', PoseStamped, queue_size=1),
                        rospy.Publisher(f'{self.myo_name[1]}/pose', PoseStamped, queue_size=1)]
        self.emgPub = [rospy.Publisher(f'{self.myo_name[0]}/myo_emg', Float32MultiArray, queue_size=1),
                       rospy.Publisher(f'{self.myo_name[1]}/myo_emg', Float32MultiArray, queue_size=1)]
        self.gestPub = [rospy.Publisher(f'{self.myo_name[0]}/myo_gest', Int16, queue_size=1),
                       rospy.Publisher(f'{self.myo_name[1]}/myo_gest', Int16, queue_size=1)]
        
        rospy.Timer(rospy.Duration(0.5), self.check_myo) 
        rospy.Timer(rospy.Duration(1/50), self.handle_imu) 
        rospy.Timer(rospy.Duration(1/50), self.handle_gest) 
        rospy.Timer(rospy.Duration(1/200), self.handle_emg) 
        try:
            # Init
            self.myo_driver = MyoDriver(self.config)

            # Connect
            self.myo_driver.run()

            if self.config.GET_MYO_INFO:
                # Get info
                self.myo_driver.get_info()

            print("Ready for data.")
            print()

            # Receive and handle data
            while not rospy.is_shutdown(): 
                self.myo_driver.receive()
                self.emg_val = self.myo_driver.get_emg()
                self.imu_val = self.myo_driver.get_imu()
                self.gest_val = self.myo_driver.get_gest()



        except KeyboardInterrupt:
            print("Interrupted.")

        except serial.serialutil.SerialException:
            print("ERROR: Couldn't open port. Please close MyoConnect and any program using this serial port.")

        finally:
            print("Disconnecting...")
            if self.myo_driver is not None:
                if self.config.DEEP_SLEEP_AT_KEYBOARD_INTERRUPT:
                    self.myo_driver.deep_sleep_all()
                else:
                    self.myo_driver.disconnect_all()
            print("Disconnected")

    def check_myo(self, event):
        if not self.myo_name == rospy.get_param('myo_name'):
            print("Switch upper and lower arm")
            self.myo_name = rospy.get_param('myo_name')
            self.imuPub = [rospy.Publisher(f'{self.myo_name[0]}/myo_imu', Imu, queue_size=1),
                            rospy.Publisher(f'{self.myo_name[1]}/myo_imu', Imu, queue_size=1)]
            self.oriPub = [rospy.Publisher(f'{self.myo_name[0]}/myo_ori', Vector3, queue_size=1),
                        rospy.Publisher(f'{self.myo_name[1]}/myo_ori', Vector3, queue_size=1)]
            self.oriDegPub = [rospy.Publisher(f'{self.myo_name[0]}/myo_ori_deg', Vector3, queue_size=1),
                            rospy.Publisher(f'{self.myo_name[1]}/myo_ori_deg', Vector3, queue_size=1)]
            self.posePub = [rospy.Publisher(f'{self.myo_name[0]}/pose', PoseStamped, queue_size=1),
                            rospy.Publisher(f'{self.myo_name[1]}/pose', PoseStamped, queue_size=1)]
            self.emgPub = [rospy.Publisher(f'{self.myo_name[0]}/myo_emg', Float32MultiArray, queue_size=1),
                        rospy.Publisher(f'{self.myo_name[1]}/myo_emg', Float32MultiArray, queue_size=1)]
            self.gestPub = [rospy.Publisher(f'{self.myo_name[0]}/myo_gest', Int16, queue_size=1),
                        rospy.Publisher(f'{self.myo_name[1]}/myo_gest', Int16, queue_size=1)]
 
    def handle_imu(self, event):
        """ Adapted from https://github.com/uts-magic-lab/ros_myo """
        if self.imu_val is not None:
            # print("imu = ", self.imu_val)
            myo_idx = self.imu_val[0]
            quat1 = self.imu_val[1]
            quat = []
            for q in quat1:
                quat.append(q*-1)
            acc = self.imu_val[2]
            gyro = self.imu_val[3]

            h = Header()
            h.stamp = rospy.Time.now()
            # frame_id is node name without /
            h.frame_id = rospy.get_name()[1:]
            # We currently don't know the covariance of the sensors with each other
            cov = [0, 0, 0, 0, 0, 0, 0, 0, 0]
            quat = Quaternion(quat1[0] / 16384.0,
                              quat1[1] / 16384.0,
                              quat1[2] / 16384.0,
                              quat1[3] / 16384.0)
            # Normalize the quaternion and accelerometer values
            quatNorm = sqrt(quat.x * quat.x + quat.y *
                            quat.y + quat.z * quat.z + quat.w * quat.w)
            normQuat = Quaternion(quat.x / quatNorm,
                                quat.y / quatNorm,
                                quat.z / quatNorm,
                                quat.w / quatNorm)
            normAcc = Vector3(acc[0] / 2048.0,
                            acc[1] / 2048.0,
                            acc[2] / 2048.0)
            normGyro = Vector3(gyro[0] / 16.0, gyro[1] / 16.0, gyro[2] / 16.0)
            imu = Imu(h, normQuat, cov, normGyro, cov, normAcc, cov)
            roll, pitch, yaw = euler_from_quaternion([normQuat.x,
                                                    normQuat.y,
                                                    normQuat.z,
                                                    normQuat.w])
            self.imuPub[myo_idx].publish(imu)
            self.oriPub[myo_idx].publish(Vector3(roll, pitch, yaw))
            self.oriDegPub[myo_idx].publish(Vector3(degrees(roll), degrees(pitch), degrees(yaw)))
            self.posePub[myo_idx].publish(PoseStamped(h,Pose(Point(0.0,0.0,0.0),normQuat)) )


    def handle_emg(self, event):
        if self.emg_val is not None:
            # print("emg = ", self.emg_val)
            msg = Float32MultiArray()
            msg.data = self.emg_val[1]
            myo_idx = self.emg_val[0]
            self.emgPub[myo_idx].publish(msg)
    
    def handle_gest(self, event):
        if self.gest_val is not None:
            print("gest = ", self.gest_val)
            msg = Int16()
            msg.data = self.gest_val[1][1]  # myo bluetooth config for classifier is type, val, xdir, _, _, _
            myo_idx = self.gest_val[0]
            self.gestPub[myo_idx].publish(msg)


def main():
    """ The main() function. """
    rospy.init_node('connect_myo')
    handler = Handler()
    rospy.spin()

if __name__ == '__main__':
    try:
        main()
    except rospy.ROSInterruptException:
        pass