#!/usr/bin/env python3
import rospy
from std_msgs.msg import Float32MultiArray, Int16
import enum
import numpy as np
from arm_control.utils import butter_highpass_filter, getTSD
from arm_control.classifier import predict


class Pose(enum.Enum):
    REST = 0
    FIST = 1
    WAVE_IN = 2
    WAVE_OUT = 3
    FINGERS_SPREAD = 4
    THUMB_TO_PINKY = 5
    UNKNOWN = 255

class Handler:
    def __init__(self):
        self.last_time = None
        self.current_time = None
        self.emg_examples = None
        self.formated_example = None
        self.featured_example = None
        self.predicted = 0

        self.longterm_myo_names = ['REST', 'WF', 'WE', 'RD', 'UD', 'FP', 'FS', 'HC', 'FP & WF', 'FP & WE',
                                    'FP & RD', 'FP & UD', 'FS & WF', 'FS & WE', 'FS & RD', 'FS & UD', 'HC & WF',
                                    'HC & WE', 'HC & RD', 'HC & UD', 'HC & FP', 'HC & FS']

        self.emg_sub = rospy.Subscriber('myo_lower/myo_emg', Float32MultiArray, self.emg_callback)
        self.gest_sub = rospy.Subscriber('myo_lower/myo_gest', Int16, self.gest_callback)
        self.processed_emg_pub = rospy.Publisher('myo_lower/processed_emg', Float32MultiArray, queue_size = 10)
        self.pred_pub = rospy.Publisher(f'myo_lower/myo_pred', Int16, queue_size=1)
        
    def emg_callback(self, data):
        self.raw_emg = data.data

        if self.last_time is None:
            self.last_time = rospy.get_time()
            self.current_time = self.last_time
        else:
            self.last_time = self.current_time
            self.current_time = rospy.get_time()

            msg = Float32MultiArray()
            msg.data = self.proc_emg(self.raw_emg)
            self.processed_emg_pub.publish(msg)

    
    def proc_emg(self, raw_emg):
        normalized_emg = []
        for emg in raw_emg:
            if emg < 0:
                e = emg/128
            else:
                e = emg/127
            normalized_emg.append(e)
        self.format_examples(normalized_emg)
        return normalized_emg
    

    def format_examples(self, new_example, window_size=50, size_non_overlap=10):
        if self.emg_examples is None:
            self.emg_examples = new_example
        else:
            self.emg_examples = np.row_stack((self.emg_examples, new_example))
        
        # store one window_size of signal
        if len(self.emg_examples) >= window_size:
            if not np.sum(self.emg_examples) == 0:   # avoid all zero signals
                # featured_example = getTSD(example.transpose())
                # self.emg_examples.append(np.array(featured_example).transpose().flatten())
                self.formated_example = butter_highpass_filter(self.emg_examples)
                self.featured_example = getTSD(self.formated_example.transpose())
                self.predicted = predict(self.featured_example)
                msg = Int16()
                msg.data =  self.predicted  # myo bluetooth config for classifier is type, val, xdir, _, _, _
                self.pred_pub.publish(msg)
                print("predicted: ", self.predicted, " ", self.longterm_myo_names[self.predicted])
            else:
                self.formated_example = np.zeros((252))
            # Remove part of the data of the example according to the size_non_overlap variable
            self.emg_examples = self.emg_examples[size_non_overlap:]
        
        # print(self.predicted, " --- exmaple = ", np.shape(self.emg_examples), " --- ", np.shape(self.formated_example), " --- ", np.shape(self.featured_example))
        self.formated_example = None
        self.featured_example = None

    def gest_callback(self, data):
        # print("myo_lower gest = ", Pose(data.data))
        self.gest = Pose(data.data)
        if self.gest == Pose.REST or self.gest == Pose.UNKNOWN:
            self.pub_group_cmd = True
        else: 
            self.pub_group_cmd = False
    
    





def main():
    """ The main() function. """
    rospy.init_node('process_emg')
    handler = Handler()

    rospy.spin()

if __name__ == '__main__':
    try:
        main()
    except rospy.ROSInterruptException:
        pass
