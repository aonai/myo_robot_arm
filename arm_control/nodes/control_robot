#!/usr/bin/env python3
import rospy
import enum
import numpy as np
import moveit_commander
from geometry_msgs.msg import PoseStamped, Pose
from moveit_msgs.msg import MoveItErrorCodes, DisplayTrajectory, RobotState
from sensor_msgs.msg import JointState
from interbotix_xs_sdk.msg import JointGroupCommand, JointSingleCommand
from std_msgs.msg import Bool, Float32MultiArray, Header


class Pose(enum.Enum):
    REST = 0
    FIST = 1
    WAVE_IN = 2
    WAVE_OUT = 3
    FINGERS_SPREAD = 4
    THUMB_TO_PINKY = 5
    UNKNOWN = 255

class MyoPred(enum.Enum):
    REST = 0
    WF = 1
    WE = 2
    RD = 3
    UD = 4

class Handler:
    def __init__(self):
        self.cmd_freq = rospy.get_param('cmd_freq')
        self.listen_tf_period = rospy.get_param('listen_tf_period')
        self.listen_tf_period = int(self.listen_tf_period*50)
        self.PI = 3.1415926
        self.K = [4, 2, 1.5]
        self.joint_state = None
        self.tf_waist = []
        self.tf_shoulder = []
        self.tf_elbow = []

        self.gest = Pose.REST
        self.pub_group_cmd = False
        self.tmp_pred = []
        self.current_pred = MyoPred.REST

        self.errCode = MoveItErrorCodes.FAILURE 
        self.joint_state = None
        self.joint_state_name = None
        self.first_js = None
        self.robot = moveit_commander.RobotCommander(robot_description='px100/robot_description', ns='px100')
        self.scene = moveit_commander.PlanningSceneInterface(ns='px100')
        self.group = moveit_commander.MoveGroupCommander("interbotix_arm", robot_description='px100/robot_description', ns='px100')
        self.gripper_group = moveit_commander.MoveGroupCommander("interbotix_gripper", robot_description='px100/robot_description', ns='px100')
        self.display_trajectory_publisher = rospy.Publisher('/move_group/display_planned_path', DisplayTrajectory, queue_size=1)
        
        self.group.set_named_target("Home")
        self.group.go(wait=True)
        self.group.stop()
        current_joints = self.group.get_current_joint_values()
        self.last_target = current_joints.copy()


        self.add_table()
        self.cmd_pub = rospy.Publisher('px100/commands/joint_group', JointGroupCommand, queue_size = 1)
        self.single_cmd_pub = rospy.Publisher('px100/commands/joint_single', JointSingleCommand, queue_size = 1)
        self.jonit_sub = rospy.Subscriber("px100/joint_states", JointState, self.joint_callback)
        # self.gest_sub = rospy.Subscriber('myo_lower/myo_gest', Int16, self.gest_callback)
        # self.pred_sub = rospy.Subscriber('myo_lower/myo_pred', Int16, self.pred_callback)
        self.rest_bicep_sub = rospy.Subscriber('myo_upper/rest_bicep', Bool, self.rest_bicep_callback)
        self.tf_rpy_sub = rospy.Subscriber('tf_rpy', Float32MultiArray, self.tf_rpy_callback)

        rospy.Timer(rospy.Duration(1/self.cmd_freq), self.pub_cmd) 

    def gest_callback(self, data):
        # print("myo_lower gest = ", Pose(data.data))
        # print("name = ", self.joint_state_name)

        self.gest = Pose(data.data)
        if self.gest == Pose.REST or self.gest == Pose.UNKNOWN:
            self.pub_group_cmd = True
        else: 
            self.pub_group_cmd = False
    
    def check_joint_limits(self, target):
        if target[0] > self.PI:
            target[0] = -2*self.PI + target[0] 
        elif target[0] < -self.PI:
            target[0] = 2*self.PI + target[0]

        if target[1] > 100*self.PI/180:
            target[1] = 100*self.PI/180 
            print("elbow max")
        elif target[1] < -105*self.PI/180:
            target[1] = -105*self.PI/180
            print("elbow min")

        if target[2] > 80*self.PI/180:
            target[2] = 80*self.PI/180
            print("elbow max")
        elif target[2] < -100*self.PI/180:
            target[2] = -100*self.PI/180
            print("elbow min")
        print("target = ", target)

        return target

    def pub_cmd(self, event):
        self.check_pred()
        if self.pub_group_cmd or len(self.tf_waist)>self.listen_tf_period:
            current_joints = self.group.get_current_joint_values()
            target = current_joints.copy()

            # moveit_robot_state = RobotState()
            # joint_state = JointState()
            # joint_state.header = Header()
            # joint_state.header.stamp = rospy.Time.now()
            # joint_state.name = ['waist', 'shoulder', 'elbow']
            # joint_state.position = current_joints[:3]
            # moveit_robot_state = RobotState()
            # moveit_robot_state.joint_state = joint_state
            # self.group.set_start_state(moveit_robot_state)
            
            # self.last_target = current_joints.copy()
            target[0] = self.last_target[0] + self.K[0]*(sum(self.tf_waist))
            target[1] = self.last_target[1] + self.K[1]*(sum(self.tf_shoulder)) 
            target[2] = self.last_target[2] + self.K[2]*(sum(self.tf_elbow)) 

            target = self.check_joint_limits(target)
            self.last_target = target

            self.tf_waist = []
            self.tf_shoulder = []
            self.tf_elbow = []

            # rospy.sleep(2)
            self.group.set_joint_value_target(target)
            self.execute_path(block=True) 
        else:
            if self.current_pred == MyoPred.WF or self.current_pred == MyoPred.WE:
                if self.current_pred == MyoPred.WF:
                    k = 1
                else:
                    k =  -1            
                cmd_msg = JointSingleCommand()
                cmd_msg.name = self.joint_state_name[3]
                print("JS = ", self.joint_state)
                cmd_msg.cmd = self.joint_state[3] + 0.1*k
                print("command 1 = ", cmd_msg)
                self.single_cmd_pub.publish(cmd_msg)
            elif self.current_pred == MyoPred.UD:
                self.gripper_group.set_named_target("Closed")
                self.gripper_group.go(wait=True)
            elif self.current_pred == MyoPred.RD:
                self.gripper_group.set_named_target("Open")
                self.gripper_group.go(wait=True)
            self.group.stop()
            self.group.clear_pose_targets()
 
    def tf_rpy_callback(self, data):
        self.tf_waist.append(data.data[0])
        self.tf_shoulder.append(data.data[1])
        self.tf_elbow.append(data.data[2])

        if (len(self.tf_waist)>self.listen_tf_period):
            self.tf_waist.pop(0)
            self.tf_shoulder.pop(0)
            self.tf_elbow.pop(0)
        # print("tf_rpy = ", self.tf_waist, self.tf_shoulder, self.tf_elbow)

    def add_table(self):
        """ Adds a table to the scene and display in rviz """
        rospy.sleep(0.5)
        p = PoseStamped()
        p.header.frame_id = "world"
        p.pose.position.z = -0.025
        self.scene.add_box("table", p, (1, 1, 0.05))

    def execute_path(self, block):
        """ helper function for executing planned path in move group """ 
        # rospy.logdebug("Execute plan")
        # self.group.set_start_state_to_current_state()
        # self.group.set_random_target()
        (result, plan, frac, errCode) = self.group.plan()
        # plan = self.group.go(joints = self.last_target, wait=False)
        # print("frac = ", frac)
        display_trajectory = DisplayTrajectory()
        display_trajectory.trajectory_start = self.robot.get_current_state()
        display_trajectory.trajectory.append(plan)
        self.display_trajectory_publisher.publish(display_trajectory)
        # rospy.sleep(1.0)
        # rospy.loginfo(f"err code = {errCode}")
        # rospy.loginfo(f"plan = {plan}")
        # if frac > 0.8:
        result = self.group.execute(plan, wait=block)
        self.group.stop()
        self.group.clear_pose_targets()

    def joint_callback(self, data):
        self.joint_state = list(data.position)
        # rospy.loginfo(f"joints = {self.joint_state}")
        if self.first_js is None:
            self.first_js = list(self.joint_state)
            self.joint_state_name = list(data.name)
            # print("name = ", self.joint_state_name)
       
    def pred_callback(self, data):
        pred = data.data
        self.tmp_pred.append(pred)
    
    def check_pred(self):
        counts = np.unique(self.tmp_pred, return_counts=True)
        print(self.tmp_pred)
        print("Counts = ", counts)
        for idx, observed_pred in enumerate(counts[0]): 
            if counts[1][idx] > len(self.tmp_pred)*0.9:
                self.current_pred = MyoPred(observed_pred)
                break
            else:
                self.current_pred = MyoPred.REST
        self.tmp_pred = []
        self.pub_group_cmd = True if self.current_pred == MyoPred.REST else False
        print("Pred = ", self.current_pred, " pub group ", self.pub_group_cmd)
    
    def rest_bicep_callback(self, data):
        if data.data:
            self.K = [4, 2, 1.5]
        else:
            self.K = [0.5, 1, 0.7]


def main():
    """ The main() function. """
    rospy.init_node('control_robot')
    handler = Handler()

    rospy.spin()

if __name__ == '__main__':
    try:
        main()
    except rospy.ROSInterruptException:
        pass